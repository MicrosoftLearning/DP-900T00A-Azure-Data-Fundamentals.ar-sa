---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ar-SA
ms.lasthandoff: 02/05/2022
ms.locfileid: "138049995"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI — pure-JavaScript BigInts [![Build status](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi) [![jsbi on npm](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI هو تطبيق pure-JavaScript [لطلب ECMAScript BigInt](https://tc39.es/proposal-bigint/)، والذي أصبح رسميًا جزءًا من لغة JavaScript في ES2020.

## <a name="installation"></a>التثبيت

```sh
npm install jsbi --save
```

## <a name="usage"></a>الاستخدام

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

ملاحظة: استدعِ `toString` صراحة على أي مثيلة `JSBI` عند `console.log()` بها لرؤية تمثيلها الرقمي (على سبيل المثال `String(max)` أو `max.toString()`). من دونها (على سبيل المثال `console.log(max)`)، سترى بدلاً من ذلك الكائن الذي يمثل القيمة.

استخدم [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) لنقل رمز JSBI إلى رمز BigInt الأصلي.

راجع التعليمات التفصيلية أدناه لمزيد من المعلومات.

## <a name="why"></a>لماذا؟

[يتم شحن BigInts الأصلي بالفعل](https://v8.dev/features/bigint) في المتصفحات الحديثة (في وقت كتابة هذا التقرير، Google Chrome 67 + وOpera 54 + وFirefox 68+) وNode.js (v10.4 +)، ومن المتوقع أن تأتي إلى متصفحات أخرى في المستقبل - مما يعني أنك لا يمكنك استخدامها بعد إذا كنت تريد تشغيل التعليمات البرمجية الخاصة بك في كل مكان.

لاستخدام BigInts في التعليمات البرمجية الخاصة بك اليوم، تحتاج إلى مكتبة. ولكن هناك صعوبة: اقتراح BigInt يغير سلوك المشغلين (مثل `+` و`>=`، إلخ) للعمل على BigInts. هذه التغييرات من المستحيل أن تتم تعبئتها مباشرة. كما أنها تجعل من غير الممكن (في معظم الحالات) نقل شفرة BigInt إلى رمز احتياطي باستخدام Babel أو أدوات مماثلة. والسبب هو أن مثل هذا النقل يجب أن يحل محل كل مشغل واحد في البرنامج باستدعاء لبعض الوظائف التي تقوم بإجراء فحوصات النوع على مدخلاتها، مما قد يؤدي إلى عقوبة أداء غير مقبولة.

الحل هو القيام بذلك في الاتجاه المعاكس: كتابة التعليمات البرمجية باستخدام بناء جملة المكتبة، و[نقلها إلى رمز BigInt الأصلي](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) عند توفره. تم تصميم JSBI لهذا الغرض بالضبط: فهو يوفر تنفيذ BigInt "polyfill" الذي يتصرف تمامًا مثل BigInts الأصلي القادم، ولكن مع بناء جملة يمكنك شحنه على جميع المتصفحات، اليوم.

مزاياها على المكتبات الأخرى ذات الأعداد الصحيحة الكبيرة الموجودة هي:

- يتصرف تماما مثل BigInts الأصلي عندما تصبح متاحة، لذلك للترحيل إلى تلك، يمكنك تحديث بناء جملة التعليمات البرمجية الخاصة بك [ميكانيكيًا](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint)؛ لن تكون هناك حاجة إلى إعادة التفكير في منطقها.
- تركيز قوي على الأداء. في المتوسط، JSBI تنافسي الأداء مع التنفيذ الأصلي الذي يقوم Google Chrome بشحنه حاليًا.

## <a name="how"></a>كيف؟‬

باستثناء الاختلافات الميكانيكية في بناء الجملة، فإنك تستخدم JSBI-BigInts تمامًا [كما تستخدم BigInts الأصلي](https://developers.google.com/web/updates/2018/05/bigint). حتى أن بعض الأشياء تبدو متشابهة، بعد استبدال `BigInt` بـ`JSBI.BigInt`:

| ‏‏التشغيل            | BigInts الأصلي          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| الإنشاء من السلسلة | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| الإنشاء من الرقم | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| التحويل إلى سلسلة | `a.toString(radix)`     | `a.toString(radix)`      |
| التحويل إلى رقم | `Number(a)`             | `JSBI.toNumber(a)`       |
| الاقتطاع           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| التحقق من النوع           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

يتم استبدال معظم المشغلين باستدعاءات الطريقة:

| ‏‏التشغيل                   | BigInts الأصلي | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| الجمع                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| الطرح                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| الضرب              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| القسم                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| الباقي                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| الرفع إلى الأس              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| الرفض                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| نفي Bitwise            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| النقل إلى اليسار               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| النقل إلى اليمين              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| Bitwise AND               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| Bitwise OR                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| Bitwise XOR               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| مقارنة مع BigInts الأخرى | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

تعمل الوظائف المذكورة أعلاه فقط على BigInts. (لا تقوم بإجراء فحوصات النوع في التنفيذ الحالي، لأن هذه التسجيلات مضيعة للوقت عندما نفترض أنك تعرف ما تفعله. لا تحاول الاتصال بها بمدخلات أخرى، وإلا ستحصل على إخفاقات "مثيرة للاهتمام"!)

بعض العمليات مثيرة للاهتمام بشكل خاص عندما تعطيها مدخلات من أنواع مختلطة، على سبيل المثال مقارنة BigInt برقم، أو تسلسل سلسلة مع BigInt. يتم تنفيذها كوظائف ثابتة سميت على اسم المشغلين الأصليين المعنيين:

| ‏‏التشغيل                       | BigInts الأصلي | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| مقارنة المساواة المجردة    | `x == y`       | `JSBI.EQ(x, y)`  |
| عام "لا يساوي"             | `x != y`       | `JSBI.NE(x, y)`  |
| عام "أقل من"             | `x < y`        | `JSBI.LT(x, y)`  |
| عام "أصغر من أو يساوي"    | `x <= y`       | `JSBI.LE(x, y)`  |
| عام "أكبر من"          | `x > y`        | `JSBI.GT(x, y)`  |
| عام "أكبر من أو يساوي" | `x >= y`       | `JSBI.GE(x, y)`  |
| إضافة عامة                | `x + y`        | `JSBI.ADD(x, y)` |

تشير أسماء المتغيرات `x` و`y` هنا إلى أن المتغيرات يمكن أن تشير إلى أي شيء، على سبيل المثال: `JSBI.GT(101.5, BigInt('100'))` أو `str = JSBI.ADD('result: ', BigInt('0x2A'))`.

لسوء الحظ، هناك أيضًا بعض الأشياء غير المدعومة على الإطلاق:

| عملية غير معتمدة | BigInts الأصلي | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| الأحرف              | `a = 123n;`    | غير متوفر ☹                                |
| الزيادة             | `a++`          | غير متوفر ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| النقصان             | `a--`          | غير متوفر ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

من المستحيل تكرار السلوك الدقيق للمشغلين `++` و`--` ذوي الوظائف الثابتة. نظرًا لأن JSBI يهدف إلى أن يتم نقله بعيدًا في نهاية المطاف، فإنه لا يوفر بديلًا مشابهًا ولكن مختلفًا. يمكنك استخدام `JSBI.add()` و`JSBI.subtract()` بدلاً من ذلك.

## <a name="when"></a>متى؟

الآن! مكتبة JSBI جاهزة للاستخدام اليوم.

بمجرد دعم BigInts في كل مكان، استخدم [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) لنقل رمز JSBI الخاص بك إلى رمز BigInt الأصلي مرة واحدة وإلى الأبد.

عرض [متتبع المواضيع لدينا](https://github.com/GoogleChromeLabs/jsbi/issues) لمعرفة المزيد حول خططنا المستقبلية لـJSBI، ويرجى الانضمام إلى المناقشة!

هناك خطة مستقبلية أكثر غموضًا تتمثل في استخدام مكتبة JSBI (أو ملحق لها) كنقطة انطلاق لوظائف إضافية متعلقة بـBigInt. الاقتراح الرسمي هو الحد الأدنى إلى حد ما عن قصد، ويترك المزيد من "وظائف المكتبة" لمقترحات المتابعة. الأمثلة هي وظيفة مدمجة `exp`+`mod`، ووظائف معالجة البت.

## <a name="development"></a>التطوير

1. استنساخ هذا المستودع و`cd` إلى الدليل المحلي.

1. استخدم الإصدار Node.js المحدد في `.nvmrc`:

     ```sh
     nvm use
     ```

1. تثبيت تبعيات التطوير:

    ```sh
    npm install
    ```

1. تشغيل الاختبارات:

    ```sh
    npm test
    ```

    راجع `npm run` لقائمة الأوامر.

## <a name="for-maintainers"></a>للمشرفين

### <a name="how-to-publish-a-new-release"></a>كيفية نشر إصدار جديد

1. على الفرع `main`، ضع رقم الإصدار في `package.json`:

    ```sh
    npm version patch -m 'Release v%s'
    ```

    بدلًا من `patch`، استخدم `minor` أو `major` [حسب الحاجة](https://semver.org/).

    لاحظ أن هذا ينتج علامة Git commit +.

1. ادفع التزام الإصدار ووضع علامة:

    ```sh
    git push
    ```

    ثم تقوم CI الخاصة بنا تلقائيًا بنشر الإصدار الجديد إلى npm.
