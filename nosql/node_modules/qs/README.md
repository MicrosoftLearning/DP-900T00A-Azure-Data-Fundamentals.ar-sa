---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ar-SA
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050134"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![Version Badge][2]][1]</sup>

[![Build Status][3]][4]
[![dependency status][5]][6]
[![dev dependency status][7]][8]
[![License][license-image]][license-url]
[![Downloads][downloads-image]][downloads-url]

[![npm badge][11]][1]

سلسلة استعلام تحليل وسلسلة مكتبة مع بعض الأمان الإضافي.

المشرف العام: [Jordan Harband](https://github.com/ljharb)

تم إنشاء وحدة **qs** في الأصل وصيانتها بواسطة [TJ Holowaychuk](https://github.com/visionmedia/node-querystring).

## <a name="usage"></a>الاستخدام

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>تحليل الكائنات

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

يتيح لك **qs** إنشاء كائنات متداخلة داخل سلاسل الاستعلام الخاصة بك، من خلال إحاطة اسم المفاتيح الفرعية بأقواس مربعة `[]`.
على سبيل المثال، يتم تحويل السلسلة `'foo[bar]=baz'` إلى:

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

عند استخدام `plainObjects` الخيار، يتم إرجاع القيمة المحللة ككائن فارغ، تم إنشاؤه عبر `Object.create(null)` وعلى هذا النحو، يجب أن تدرك أن طرق النموذج الأولي لن تكون موجودة عليه ويمكن للمستخدم تعيين هذه الأسماء إلى أي قيمة يريدها:

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

بشكل افتراضي، يتم تجاهل المعلمات التي من شأنها الكتابة فوق الخصائص الموجودة على النموذج الأولي للكائن، إذا كنت ترغب في الاحتفاظ بالبيانات من تلك الحقول، فإما استخدام `plainObjects` كما هو مذكور أعلاه، أو تعيين `allowPrototypes` إلى `true` والتي ستسمح لإدخال المستخدم بالكتابة فوق هذه الخصائص. *تحذير* عادة ما تكون فكرة سيئة تمكين هذا الخيار لأنه يمكن أن يسبب مشاكل عند محاولة استخدام الخصائص التي تم الكتابة فوقها. كن حذراً دائماً مع هذا الخيار.

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

تعمل سلاسل URI المشفرة أيضاً:

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

يمكنك أيضاً تداخل الكائنات الخاصة بك، مثل `'foo[bar][baz]=foobarbaz'`:

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

بشكل افتراضي، عند تداخل الكائنات ستقوم **qs** بتحليل ما يصل إلى 5 فروع فقط. هذا يعني أنه إذا حاولت تحليل سلسلة مثل `'a[b][c][d][e][f][g][h][i]=j'` الكائن الناتج الخاص بك سيكون:

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

يمكن تجاوز هذا العمق عن طريق تمرير خيار `depth` إلى `qs.parse(string, [options])`:

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

يساعد حد العمق في التخفيف من إساءة الاستخدام عند استخدام **qs** لتحليل مدخلات المستخدم، ويوصى بالاحتفاظ بها عدداً صغيراً بشكل معقول.

لأسباب مماثلة، ستقوم **qs** افتراضياً بتحليل ما يصل إلى 1000 معلمة فقط. يمكن تجاوز هذا عن طريق تمرير خيار `parameterLimit`:

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

لتجاوز علامة الاستفهام البادئة، استخدم `ignoreQueryPrefix`:

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

يمكن أيضاً تمرير محدد اختياري:

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

يمكن أن تكون المحددات تعبيراً منتظماً أيضاً:

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

يمكن استخدام الخيار `allowDots` لتمكين تدوين النقاط:

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

إذا كان عليك التعامل مع المتصفحات أو الخدمات القديمة، فهناك أيضاً دعم لفك تشفير الثمانيات المشفرة بنسبة مئوية مثل iso-8859-1:

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

تضيف بعض الخدمات قيمة أولية `utf8=✓` إلى النماذج بحيث يكون من المرجح أن ترسل إصدارات Internet Explorer القديمة النموذج ك utf-8. بالإضافة إلى ذلك، يمكن للخادم التحقق من القيمة مقابل الترميزات الخاطئة لحرف علامة الاختيار واكتشاف أنه `application/x-www-form-urlencoded`لم يتم *إرسال سلسلة استعلام أو* نص أساسي كـutf-8، على سبيل المثال. إذا كان النموذج يحتوي على معلمة `accept-charset` أو كانت الصفحة المحتوية تحتوي على مجموعة أحرف مختلفة.

يدعم **qs** هذه الآلية عبر الخيار `charsetSentinel`.
إذا تم تحديده، سيتم حذف المعلمة `utf8` من الكائن الذي تم إرجاعه. سيتم استخدامه للتبديل إلى `iso-8859-1`/`utf-8` الوضع اعتماداً على كيفية ترميز علامة الاختيار.

**هام**: عند تحديد كل `charset` من الخيار والخيار `charsetSentinel`، سيتم تجاوز الخيار `charset` عندما يحتوي الطلب على `utf8` معلمة يمكن من خلالها استنتاج مجموعة الأحرف الفعلية. وبهذا المعنى، `charset` تتصرف الإرادة كمجموعة الأحرف الافتراضية بدلاً من مجموعة الأحرف الموثوقة.

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

إذا كنت ترغب في فك تشفير بناء الجملة `&#...;` إلى الحرف الفعلي، فيمكنك تحديد `interpretNumericEntities` الخيار أيضاً:

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

كما أنه يعمل عند اكتشاف مجموعة الأحرف في الوضع `charsetSentinel`.

### <a name="parsing-arrays"></a>تحليل المصفوفات

يمكن لـ **qs** أيضاً تحليل المصفوفات باستخدام ترميز مماثل`[]`:

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

يمكنك تحديد فهرس أيضاً:

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

لاحظ أن الفرق الوحيد بين فهرس في صفيف ومفتاح في كائن هو أن القيمة بين الأقواس يجب أن تكون رقماً لإنشاء صفيف. عند إنشاء صفائف ذات مؤشرات محددة، ستقوم **qs** بضغط صفيف متفرق على القيم الموجودة فقط التي تحافظ على ترتيبها:

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

يمكنك أيضاً استخدام الخيار `allowSparse` لتحليل المصفوفات المتناثرة:

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

لاحظ أن السلسلة الفارغة هي أيضاً قيمة، وسيتم الاحتفاظ بها:

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

سيحد **qs** أيضاً من تحديد المؤشرات في صفيف إلى مؤشر أقصى من `20`. سيتم بدلاً من ذلك تحويل أي أعضاء صفيف لديهم فهرس أكبر من `20` إلى كائن مع الفهرس كمفتاح. هناك حاجة إلى ذلك للتعامل مع الحالات التي يرسل فيها شخص ما، على سبيل المثال، `a[999999999]` وسيستغرق الأمر وقتاً طويلاً للتكرار عبر هذه المجموعة الضخمة.

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

يمكن تجاوز هذا الحد عن طريق تمرير خيار `arrayLimit` :

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

لتعطيل تحليل الصفيف بالكامل، اضبط `parseArrays` على `false`.

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

إذا قمت بخلط الرموز، فسيقوم **qs** بدمج العنصرين في كائن:

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

يمكنك أيضاً إنشاء صفائف من الكائنات:

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

يستخدم بعض الأشخاص الفاصلة للانضمام إلى الصفيف، ويمكن لـ **qs** تحليلها:
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
(_لا يمكن لهذا تحويل الكائنات المتداخلة، مثل `a={b:1},{c:d}`_ )

### <a name="stringifying"></a>التشديد

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

عند التشديد، يقوم **qs** افتراضياً بتشفير URI للإخراج. يتم ربط الكائنات كما تتوقع:

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

يمكن تعطيل هذا الترميز عن طريق تعيين الخيار `encode` إلى `false`:

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

يمكن تعطيل الترميز للمفاتيح عن طريق تعيين الخيار `encodeValuesOnly` إلى `true`:
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

يمكن أيضاً استبدال هذا الترميز بطريقة ترميز مخصصة تم تعيينها كخيار `encoder`:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

_(ملاحظة: لا ينطبق الخيار `encoder` إذا كان `encode` `false`)_

مثل `encoder` هناك خيار `decoder` لـ`parse` لتجاوز فك تشفير الخصائص والقيم:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

يمكنك ترميز المفاتيح والقيم باستخدام منطق مختلف باستخدام وسيطة الكتابة المتوفرة لجهاز الترميز:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

يتم توفير وسيطة النوع أيضاً إلى وحدة فك الترميز:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

سيتم عرض أمثلة تتجاوز هذه النقطة كما لو أن الإخراج غير مشفر URI للوضوح. يرجى ملاحظة أن قيم الإرجاع في هذه الحالات *سيتم* ترميزها بـURI أثناء الاستخدام الحقيقي.

عندما تكون المصفوفات مشدودة، يتم إعطاؤها بشكل افتراضي مؤشرات صريحة:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

يمكنك تجاوز ذلك عن طريق تعيين الخيار `indices` إلى `false`:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

يمكنك استخدام الخيار `arrayFormat` لتحديد تنسيق صفيف الإخراج:

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

عندما تكون الكائنات مشدودة، فإنها تستخدم بشكل افتراضي تدوين الأقواس:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

يمكنك تجاوز ذلك لاستخدام تدوين النقاط عن طريق تعيين الخيار `allowDots` إلى `true`:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

ستحذف السلاسل الفارغة والقيم الخالية القيمة، ولكن تظل علامة يساوي (=) في مكانها:

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

المفتاح بدون قيم (مثل كائن أو صفيف فارغ) لن يؤدي إلى إرجاع أي شيء:

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

سيتم حذف الخصائص التي تم تعيينها بالكامل `undefined`:

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

قد يتم اختياريًا إعداد سلسلة الاستعلام بعلامة استفهام:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

يمكن تجاوز المحدد مع stringify كذلك:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

إذا كنت تريد فقط تجاوز تسلسل الكائنات `Date`، فيمكنك توفير خيار `serializeDate`:

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

يمكنك استخدام الخيار `sort` للتأثير على ترتيب مفاتيح المعلمات:

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

أخيراً، يمكنك استخدام الخيار `filter` لتقييد المفاتيح التي سيتم تضمينها في الإخراج التسلسلي.
إذا قمت بتمرير وظيفة، يتم استدعاؤها لكل مفتاح للحصول على قيمة الاستبدال. وإلا، إذا قمت بتمرير صفيف، استخدامه لتحديد الخصائص وفهارس الصفيف للترابط:

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>التعامل مع قيم `null`

بشكل افتراضي، يتم التعامل مع قيم `null` مثل السلاسل الفارغة:

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

التحليل لا يميز بين المعلمات مع وبدون علامات متساوية. يتم تحويل كلاهما إلى سلاسل فارغة.

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

للتمييز بين القيم `null` والسلاسل الفارغة، استخدم العلامة `strictNullHandling`. في سلسلة النتائج، لا تحتوي القيم `null` على علامة `=`:

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

لتحليل القيم بدون رجوع `=` إلى `null` استخدم العلامة `strictNullHandling`:

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

لتخطي مفاتيح العرض ذات القيم `null` تماماً، استخدم العلامة `skipNulls`:

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

إذا كنت تتواصل مع الأنظمة القديمة، يمكنك التبديل إلى `iso-8859-1` باستخدام الخيار `charset`:

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

سيتم تحويل الأحرف غير الموجودة في `iso-8859-1` إلى كيانات رقمية، على غرار ما تفعله المتصفحات:

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

يمكنك استخدام خيار `charsetSentinel` للإعلان عن الحرف عن طريق تضمين معلمة `utf8=✓` مع الترميز المناسب إذا كانت علامة الاختيار، على غرار ما يفعله Ruby on Rails وغيره عند إرسال النماذج.

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>التعامل مع مجموعات الأحرف الخاصة

بشكل افتراضي، يتم تشفير الأحرف وفك تشفيرها في `utf-8` و`iso-8859-1` ويتم أيضاً تضمين الدعم عبر المعلمة `charset`.

إذا كنت ترغب في ترميز سلاسل الاستعلامات إلى مجموعة أحرف مختلفة (أي [Shift JIS)](https://en.wikipedia.org/wiki/Shift_JIS)، فيمكنك استخدام مكتبة [`qs-iconv`](https://github.com/martinheidegger/qs-iconv):

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

يعمل هذا أيضاً لفك تشفير سلاسل الاستعلام:

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>ترميز مساحة المعيار RFC 3986 والمعيار RFC 1738

RFC3986 يستخدم كخيار افتراضي ويشفر ' ' إلى *٪20* وهو متوافق مع الإصدارات السابقة.
في الوقت نفسه، يمكن ربط الإخراج وفقاً لـRFC1738 بـ' ' يساوي "+".

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>الأمان

يرجى إرسال بريد إلكتروني [@ljharb](https://github.com/ljharb) أو رؤية https://tidelift.com/security إذا كان لديك ثغرة أمنية محتملة للإبلاغ عنها.

## <a name="qs-for-enterprise"></a>qs للمؤسسات

متوفر كجزء من اشتراك Tidelift

يعمل المشرفون على qs والآلاف من الحزم الأخرى مع Tidelift لتقديم الدعم التجاري والصيانة للتبعيات مصدر مفتوح التي تستخدمها لإنشاء تطبيقاتك. وفر الوقت وقلل المخاطر وحسن صحة التعليمات البرمجية، مع الدفع للمشرفين على التبعيات الدقيقة التي تستخدمها. ⁧[⁩معرفة المزيد.⁧](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)⁩

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
