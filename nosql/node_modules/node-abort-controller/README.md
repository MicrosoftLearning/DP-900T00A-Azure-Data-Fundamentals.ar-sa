---
ms.openlocfilehash: ca2cf748b426d17058b55202a60ece01d9e05592
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ar-SA
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050044"
---
# <a name="node-abort-controller"></a>node-abort-controller

AbortController Polyfill Node.JS على أساس EventEmitter

[![Build Status](https://dev.azure.com/stfaul/node-abort-controller/_apis/build/status/southpolesteve.node-abort-controller?branchName=master)](https://dev.azure.com/stfaul/node-abort-controller/_build/latest?definitionId=3&branchName=master)

## <a name="usage"></a>الاستخدام

```js
import fetch from 'node-fetch'
import AbortController from 'node-abort-controller'

const controller = new AbortController()
const signal = controller.signal

await fetch('https:/www.google.com', { signal })

// Abort after 500ms. Effectively a timeout
setTimeout(() => controller.abort(), 500)
```

## <a name="why-would-i-use-this"></a>لماذا أستخدم هذا؟

قد لا تحتاج إلى ذلك! بشكل عام، هناك ثلاث بيئات يمكن تشغيل شفرة JavaScript الخاصة بك فيها:

- Node
- المتصفحات الحديثة (وليس إنترنت إكسبلورر)
- المتصفحات القديمة (غالبًا إنترنت إكسبلورر)

بالنسبة لواجهات برمجة تطبيقات JS الحديثة، ستحصل كل بيئة بشكل مثالي على polyfill:

- فقط إذا كان يحتاج إلى واحد
- خاصة بالمنصة.

في الممارسة العملية، هذا صعب. تعد الأدوات مثل webpack وbrowserify رائعة في التأكد من أن الأشياء تعمل خارج الصندوق في جميع البيئات. ولكن من السهل جدًا أن تفشل في كلتا النقطتين أعلاه. في جميع الاحتمالات، ينتهي بك الأمر إلى شحن أقل من polyfills المثالي على المنصات التي لا تحتاج إليها حتى. إذن ما الذي يجب على المطور القيام به؟ في حالة `fetch` و`AbortController` لقد قمت بالعمل نيابة عنك. هذا دليل لهذا العمل.

إذا كنت تقوم ببناء ...

#### <a name="application-running-in-modern-browsers"></a>تطبيق يعمل في المتصفحات الحديثة:

تهانينا! لا تحتاج إلى مكتبة أو polyfill على الإطلاق! إغلاق علامة التبويب هذه. إلغاء تثبيت هذه الحزمة.

#### <a name="application-running-in-modern-browsers-and-node-such-as-a-server-side-rendered-js-app"></a>تطبيق يعمل في المتصفحات الحديثة والعقدة (مثل تطبيق JS من جانب الخادم):

استخدم _هذه الحزمة_ و[node-fetch](https://www.npmjs.com/package/node-fetch). إنه الحد الأدنى مما تحتاج إليه.

#### <a name="application-supporting-legacy-browsers-and-not-node"></a>تطبيق يدعم المتصفحات القديمة وليس العقدة:

استخدم [abort-controller](https://www.npmjs.com/package/abort-controller) و[whatwg-fetch](https://www.npmjs.com/package/whatwg-fetch). هذه هي polyfills أكثر اكتمالًا التي ستعمل في جميع بيئات المتصفح.

#### <a name="application-supporting-legacy-browsers-and-node"></a>تطبيق يدعم المتصفحات القديمة والعقدة AND:

استخدم [abort-controller](https://www.npmjs.com/package/abort-controller)[وcross-fetch](https://www.npmjs.com/package/cross-fetch). نفس ما سبق، باستثناء الجلب المتقاطع سوف polyfill بشكل صحيح في كل من المتصفح وnode.js

#### <a name="library-being-consumed-by-other-applications-and-using-fetch-internally"></a>المكتبة التي تستهلكها تطبيقات أخرى وتستخدم `fetch` داخليًا:

استخدم _هذه الحزمة_ و[node-fetch](https://www.npmjs.com/package/node-fetch). إنها المجموعة الأصغر والأقل أهمية للمستخدمين النهائيين. سيحتاج مطورو التطبيقات الذين يستهدفون Internet Exploer إلى polyfill `AbortController` و`fetch` من تلقاء أنفسهم. لكن مكتبتك لن تفرض عمليات تعبئة غير ضرورية على المطورين الذين يستهدفون المتصفحات الحديثة فقط.

## <a name="goals"></a>الأهداف

مع وضع الدليل أعلاه في الاعتبار، تحتوي هذه المكتبة على مجموعة محددة للغاية من الأهداف:

1. توفير الحد الأدنى من polyfill في node.js
2. لا توفر polyfill في أي بيئة متصفح

هذا هو المثالي _لمؤلفي المكتبات_ الذين يستخدمون `fetch` و`AbortController` داخليًا ويستهدفون _كلًا_ من مطوري المتصفح والعقدة.

## <a name="prior-art"></a>حالة التقنية الصناعية السابقة

شكرًا لـ@mysticatea و https://github.com/mysticatea/abort-controller. إنه polyfill `AbortController` رائع ومثالي للعديد من حالات الاستخدام.
