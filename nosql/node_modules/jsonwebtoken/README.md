---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ar-SA
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050053"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **الإنشاء** | **التبعية** |
|-----------|---------------|
| [![Build Status](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![Dependency Status](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


تنفيذ [رموز الويب JSON المميزة](https://tools.ietf.org/html/rfc7519).

تم تطوير هذا ضد `draft-ietf-oauth-json-web-token-08`. يستفيد من [node-jws](https://github.com/brianloveswords/node-jws)

# <a name="install"></a>تثبيت

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>ملاحظات الترحيل

* [من v7 إلى v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>الاستخدام

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(غير متزامن) إذا تم توفير معاودة الاتصال، استدعاء معاودة الاتصال باستخدام `err` JWT أو JWT.

(متزامن) إرجاع JsonWebToken كسلسلة

`payload` يمكن أن يكون كائنًا حرفيًا أو مخزن مؤقت أو سلسلة تمثل JSON صالحة. 
> **يرجى _ملاحظة_ أن** `exp` أو أي مطالبة أخرى يتم تعيينها فقط إذا كانت الحمولة عبارة عن كائن حرفي. لا يتم التحقق من حمولات المخزن المؤقت أو السلسلة للتأكد من صحة JSON.

> إذا لم يكن `payload` مخزن مؤقت أو سلسلة، يتم إجباره إلى سلسلة باستخدام `JSON.stringify`.

`secretOrPrivateKey` عبارة عن سلسلة أو مخزن مؤقت أو كائن يحتوي إما على سر خوارزميات HMAC أو المفتاح الخاص المشفر PEM لـRSA وECDSA. في حالة وجود مفتاح خاص مع عبارة مرور، يمكن استخدام كائن `{ key, passphrase }` (استنادًا إلى [وثائق التشفير](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format))، في هذه الحالة تأكد من تمرير الخيار `algorithm`.

`options`:

* `algorithm` (default: `HS256`)
* `expiresIn`: معبرًا عنه بالثواني أو بسلسلة تصف فترة زمنية [zeit/ms](https://github.com/zeit/ms). 
  > مثل: `60`، `"2 days"`، `"10h"`، `"7d"`. يتم تفسير القيمة الرقمية على أنها عدد ثواني. إذا كنت تستخدم سلسلة تأكد من توفير وحدات الوقت (أيام، ساعات، إلخ)، وإلا يتم استخدام وحدة المللي ثانية افتراضيًا (`"120"` تساوي `"120ms"`).
* `notBefore`: معبرًا عنه بالثواني أو بسلسلة تصف فترة زمنية [zeit/ms](https://github.com/zeit/ms). 
  > مثل: `60`، `"2 days"`، `"10h"`، `"7d"`. يتم تفسير القيمة الرقمية على أنها عدد ثواني. إذا كنت تستخدم سلسلة تأكد من توفير وحدات الوقت (أيام، ساعات، إلخ)، وإلا يتم استخدام وحدة المللي ثانية افتراضيًا (`"120"` تساوي `"120ms"`).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: إذا كان صحيحًا، فستقوم وظيفة الإشارة بتعديل كائن الحمولة مباشرة. هذا مفيد إذا كنت بحاجة إلى مرجع أولي إلى الحمولة بعد تطبيق المطالبات عليها ولكن قبل أن يتم ترميزها إلى رمز مميز.



> لا توجد قيم افتراضية لـ`expiresIn`، `notBefore`، `audience`، `subject`، `issuer`.  يمكن أيضًا توفير هذه المطالبات في الحمولة مباشرة مع `exp`، `nbf`، `aud`، `sub` و`iss` على التوالي ولكن **_لا يمكنك_** تضمينها في كلا المكانين.

تذكر أن `exp` و`nbf` و`iat` هي **NumericDate**، راجع [انتهاء صلاحية الرمز المميز ذي الصلة (مطالبة exp)](#token-expiration-exp-claim)


يمكن تخصيص الرأس عبر الكائن `options.header`.

ستتضمن jwts التي تم إنشاؤها (صادرة في) مطالبة `iat` بشكل افتراضي ما لم يتم تحديد `noTimestamp`. إذا تم إدخال `iat` في الحمولة الصافية، سيتم استخدامه بدلًا من الطابع الزمني الحقيقي لحساب أشياء أخرى مثل إعطاء `exp` فترة زمنية في `options.expiresIn`.

علامة متزامنة افتراضية (HMAC SHA256)

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

علامة متزامنة مع RSA SHA256
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

توقيع غير متزامن
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

تاريخ يعود إلى الوراء 30 ثانية jwt
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>انتهاء صلاحية الرمز المميز (مطالبة exp)

يحدد معيار JWT مطالبة `exp` بانتهاء الصلاحية. يتم تمثيل انتهاء الصلاحية **كتاريخ رقمي**:

> قيمة رقمية JSON تمثل عدد الثواني من 1970-01-01T00:00Z UTC حتى تاريخ/وقت UTC المحدد، متجاهلة الثواني الكبيسة.  هذا يعادل تعريف IEEE Std 1003.1، 2013 Edition [POSIX.1] "الثواني منذ الموعد"، حيث يتم حساب كل يوم بـ86400 ثانية بالضبط، بخلاف أنه يمكن تمثيل القيم غير الصحيحة.  راجع RFC 3339 [RFC3339] للحصول على تفاصيل حول التاريخ/الأوقات، بشكل عام و UTC بشكل خاص.

هذا يعني أن الحقل `exp` يجب أن يحتوي على عدد الثواني منذ العصر.

توقيع رمز مميز مع 1 ساعة من انتهاء الصلاحية:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

هناك طريقة أخرى لإنشاء رمز مميز مثل هذا باستخدام هذه المكتبة وهي:

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(غير متزامن) إذا تم توفير معاودة الاتصال، تعمل الدالة بشكل غير متزامن. يتم استدعاء رد الاتصال باستخدام الحمولة التي تم فك تشفيرها إذا كان التوقيع صالحًا وكانت انتهاء الصلاحية الاختياري أو الجمهور أو المصدر صالحًا. إذا لم يكن الأمر كذلك، استدعاؤه مع الخطأ.

(غير متزامن) إذا لم تم توفير معاودة الاتصال، تعمل الدالة بشكل غير متزامن. إرجاع الحمولة التي تم فك تشفيرها إذا كان التوقيع صالحا وكانت انتهاء الصلاحية الاختياري أو الجمهور أو جهة الإصدار صالحة. إذا لم يكن الأمر كذلك، فسوف يرمي الخطأ.

`token` هي سلسلة JsonWebToken

`secretOrPublicKey` عبارة عن سلسلة أو مخزن مؤقت يحتوي إما على سر خوارزميات HMAC، أو المفتاح العام المشفر PEM لـRSA وECDSA.
إذا كان `jwt.verify` يستدعى غير متزامن، يمكن أن يكون `secretOrPublicKey` وظيفة يجب أن تجلب المفتاح السري أو العام. انظر أدناه للحصول على مثال مفصل

كما هو مذكور في [هذا التعليق](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138)، هناك مكتبات أخرى تتوقع أسرار مشفرة base64 (وحدات بايت عشوائية مشفرة باستخدام base64)، إذا كانت هذه هي حالتك، فيمكنك تمرير `Buffer.from(secret, 'base64')`، من خلال القيام بذلك، سيتم فك تشفير السر باستخدام base64 وسيستخدم التحقق من الرمز المميز وحدات البايت العشوائية الأصلية.

`options`

* `algorithms`: قائمة السلاسل بأسماء الخوارزميات المسموح بها. على سبيل المثال، `["HS256", "HS384"]`.
* `audience`: إذا كنت ترغب في التحقق من الجمهور (`aud`)، فقدم قيمة هنا. يمكن التحقق من الجمهور مقابل سلسلة أو تعبير عادي أو قائمة من السلاسل و / أو التعبيرات العادية. 
  > مثل: `"urn:foo"`، `/urn:f[o]{2}/`، `[/urn:f[o]{2}/, "urn:bar"]`.
* `complete`: إرجاع كائن تم فك تشفيره `{ payload, header, signature }` بدلًا من المحتوى المعتاد للحمولة فقط.
* `issuer` (اختياري): سلسلة أو صفيف من سلاسل القيم الصالحة للحقل `iss`.
* `ignoreExpiration`: إذا `true` لم تقم بالتحقق من صحة انتهاء صلاحية الرمز المميز.
* `ignoreNotBefore`...
* `subject`: إذا كنت ترغب في التحقق من موضوع (`sub`)، فقدم قيمة هنا
* `clockTolerance`: عدد الثواني التي يجب تحملها عند التحقق من المطالبات `nbf` و`exp`، للتعامل مع اختلافات الساعة الصغيرة بين الخوادم المختلفة
* `maxAge`: الحد الأقصى للعمر المسموح به للرموز المميزة التي لا تزال صالحة. معبرًا عنه بالثواني أو بسلسلة تصف فترة زمنية [zeit/ms](https://github.com/zeit/ms). 
  > مثل: `1000`، `"2 days"`، `"10h"`، `"7d"`. يتم تفسير القيمة الرقمية على أنها عدد ثواني. إذا كنت تستخدم سلسلة تأكد من توفير وحدات الوقت (أيام، ساعات، إلخ)، وإلا يتم استخدام وحدة المللي ثانية افتراضيًا (`"120"` تساوي `"120ms"`).
* `clockTimestamp`: الوقت بالثواني الذي ينبغي استخدامه كوقت حالي لجميع المقارنات الضرورية.
* `nonce`: إذا كنت تريد التحقق من المطالبة `nonce`، فقم بتوفير قيمة سلسلة هنا. يتم استخدامه على معرف مفتوح لرموز المعرف. ([ملاحظات تنفيذ المعرف المفتوح](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(متزامن) إرجاع الحمولة التي تم فك تشفيرها دون التحقق مما إذا كان التوقيع صالحًا أم لا.

> __تحذير:__ هذا __لن__ يتحقق من صحة التوقيع. يجب __عدم__ استخدام هذا للرسائل غير الموثوق بها. من المرجح أنك تريد استخدام `jwt.verify` بدلًا من ذلك.

`token` هي سلسلة JsonWebToken

`options`:

* `json`: فرض JSON.parse على الحمولة حتى إذا كان الرأس لا يحتوي على `"typ":"JWT"`.
* `complete`: إرجاع كائن يحتوي على الحمولة والرأس اللذين تم فك تشفيرهما.

مثال

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>الأخطاء والرموز
أخطاء محتملة أثناء التحقق.
الخطأ هو الوسيطة الأولى لمعاودة الاتصال بالتحقق.

### <a name="tokenexpirederror"></a>TokenExpiredError

خطأ تم طرحه إذا انتهت صلاحية الرمز المميز.

عنصر خطأ:

* الاسم: 'TokenExpiredError'
* الرسالة: "انتهت صلاحية jwt"
* expiredAt: [ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
عنصر خطأ:

* الاسم: 'JsonWebTokenError'
* الرسالة:
  * "jwt مشوهة"
  * "توقيع jwt مطلوب"
  * 'توقيع غير صالح'
  * 'جمهور jwt غير صالح' expected: [OPTIONS AUDIENCE]'
  * 'jwt issuer invalid. expected: [OPTIONS ISSUER]'
  * 'jwt id invalid. expected: [OPTIONS JWT ID]'
  * 'jwt الموضوع غير صالح. expected: [OPTIONS SUBJECT]'

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
يتم إلقاؤها إذا كان الوقت الحالي قبل مطالبة nbf.

عنصر خطأ:

* الاسم: 'NotBeforeError'
* الرسالة: "jwt غير نشط"
* التاريخ: 2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>الخوارزميات المدعومة

مجموعة من الخوارزميات المدعومة. يتم دعم الخوارزميات التالية حاليًا.

قيمة المعلمة alg | التوقيع الرقمي أو خوارزمية MAC
----------------|----------------------------
HS256 | HMAC باستخدام خوارزمية التجزئة SHA-256
HS384 | HMAC باستخدام خوارزمية التجزئة SHA-384
HS512 | HMAC باستخدام خوارزمية التجزئة SHA-512
RS256 | RSASSA-PKCS1-v1_5 باستخدام خوارزمية التجزئة SHA-256
RS384 | RSASSA-PKCS1-v1_5 باستخدام خوارزمية التجزئة SHA-384
RS512 | RSASSA-PKCS1-v1_5 باستخدام خوارزمية التجزئة SHA-512
PS256 | RSASSA-PSS باستخدام خوارزمية التجزئة SHA-256 (العقدة فقط ^ 6.12.0 أو >= 8.0.0)
PS384 | RSASSA-PSS باستخدام خوارزمية التجزئة SHA-384 (العقدة فقط ^ 6.12.0 أو >= 8.0.0)
PS512 | RSASSA-PSS باستخدام خوارزمية التجزئة SHA-512 (العقدة فقط ^ 6.12.0 أو >= 8.0.0)
ES256 | ECDSA باستخدام منحنى P-256 وخوارزمية التجزئة SHA-256
ES384 | ECDSA باستخدام منحنى P-384 وخوارزمية التجزئة SHA-384
ES512 | ECDSA باستخدام منحنى P-521 وخوارزمية التجزئة SHA-512
بلا | لا يتضمن التوقيع الرقمي أو قيمة MAC

## <a name="refreshing-jwts"></a>JWTs منعشة

بادئ ذي بدء، نوصيك بالتفكير بعناية إذا كان التحديث التلقائي لـJWT لن يؤدي إلى أي ثغرة أمنية في نظامك.

نحن لسنا مرتاحين لتضمين هذا كجزء من المكتبة، ومع ذلك، يمكنك إلقاء نظرة [على هذا المثال](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48) لإظهار كيف يمكن تحقيق ذلك.
بصرف النظر عن هذا المثال، هناك [مشكلة](https://github.com/auth0/node-jsonwebtoken/issues/122) و[طلب سحب](https://github.com/auth0/node-jsonwebtoken/pull/172) للحصول على مزيد من المعرفة حول هذا الموضوع.

# <a name="todo"></a>TODO

* لم يتم تحديد سلسلة شهادات X.509

## <a name="issue-reporting"></a>الإبلاغ عن المشكلات

إذا عثرت على خطأ أو إذا كان لديك طلب ميزة، فيرجى الإبلاغ عنه في قسم مشكلات المستودع هذا. يرجى عدم الإبلاغ عن الثغرات الأمنية على متعقب المشكلات GitHub العامة. يفصل [برنامج الإفصاح المسؤول](https://auth0.com/whitehat) إجراءات الكشف عن المشكلات الأمنية.

## <a name="author"></a>المؤلف

[Auth0](https://auth0.com)

## <a name="license"></a>الترخيص

تم إصدار هذا المشروع بموجب ترخيص MIT. راجع ملف [الترخيص](LICENSE) لمزيد من المعلومات.
