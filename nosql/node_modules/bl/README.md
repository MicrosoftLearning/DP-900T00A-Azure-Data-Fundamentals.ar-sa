---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ar-SA
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050026"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![Build Status](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**جامع قائمة المخزن المؤقت Node.js والقارئ والبث.**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** هو كائن تخزين لمجموعات من المخازن المؤقتة للعقدة، مما يعرضها باستخدام واجهة برمجة التطبيقات الرئيسية القابلة للقراءة في المخزن المؤقت. يعمل أيضًا كدفق مزدوج حتى تتمكن من جمع المخازن المؤقتة من دفق ينبعث منها وتنبعث منها المخازن المؤقتة إلى دفق يستهلكها!

يتم الاحتفاظ بالمخازن المؤقتة الأصلية سليمة ويتم إجراء النسخ فقط حسب الضرورة. أي عمليات قراءة تتطلب استخدام مخزن مؤقت أصلي واحد ستعرض شريحة من هذا المخزن المؤقت فقط (والتي تشير إلى نفس الذاكرة مثل المخزن المؤقت الأصلي). تقوم عمليات القراءة التي تمتد عبر المخازن المؤقتة بإجراء التسلسل كما هو مطلوب وإرجاع النتائج بشفافية.

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

قم بمعاودة الاتصال به في المنشئ واستخدمه تمامًا مثل **[concat-stream](https://github.com/maxogden/node-concat-stream)** :

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

لاحظ أنه عند استخدام طريقة *معاودة الاتصال* مثل هذه، تكون المعلمة الناتجة `data` عبارة عن سلسلة من جميع الكائنات `Buffer` الموجودة في القائمة. إذا كنت ترغب في تجنب النفقات العامة لهذه السلسلة (في حالات الوعي الشديد بالأداء)، فتجنب طريقة *معاودة الاتصال* والاستماع إليها `'end'` بدلًا من ذلك، مثل البث القياسي.

أو لجلب عنوان URL باستخدام [hyperquest](https://github.com/substack/hyperquest) (يجب أن يعمل مع [الطلب](http://github.com/mikeal/request) وحتى العقدة العادية http أيضا!):

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

أو استخدمه كدفق قابل للقراءة لإعادة إنشاء قائمة من المخازن المؤقتة إلى مصدر إخراج:

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>واجهة برمجة التطبيقات (API) 

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ])
لا توجد وسيطات _مطلوبة_ للمنشئ، ولكن يمكنك تهيئة القائمة عن طريق المرور في كائن واحد `Buffer` أو صفيف من `Buffer` الكائنات.

`new` ليس مطلوبًا بشكل صارم، إذا لم تقم بإنشاء كائن جديد، سيتم ذلك تلقائيًا نيابة عنك حتى تتمكن من إنشاء مثيل جديد ببساطة مع:

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
يحدد ما إذا كان الكائن الذي تم تمريره هو `BufferList`. سيعود `true` إذا كان الكائن الذي تم تمريره مثيلا لـ`BufferList` **أو** `BufferListStream` غير `false` ذلك.

N.B. لن يرجع هذا `true` للمثيلات `BufferList` أو `BufferListStream` المنشأة بإصدارات المكتبة أو قبل إضافة هذه الطريقة الثابتة.

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
احصل على طول القائمة بالبايت. هذا هو مجموع أطوال جميع المخازن المؤقتة الموجودة في القائمة، مطروحًا منها أي إزاحة أولية لمخزن مؤقت شبه مستهلك في البداية. يجب أن تمثل بدقة العدد الإجمالي للبايت التي يمكن قراءتها من القائمة.

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` يضيف مخزن مؤقت إضافي أو قائمة المخزن المؤقت إلى القائمة الداخلية. يتم إرجاع `this` بحيث يمكن تقييده.

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` سيرجع البايت في الفهرس المحدد.

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` سيرجع البايت في الفهرس المحدد.
ترجع الطريقة `indexOf()` الفهرس الأول الذي يمكن العثور فيه على عنصر معين في BufferList أو -1 إذا لم يكن موجودًا.

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` ترجع هذه الدالة كائنًا جديدًا `Buffer` يحتوي على وحدات البايت داخل النطاق المحدد. كلاً من `start` و`end` اختياريان وسيكونان افتراضيين إلى بداية ونهاية القائمة على التوالي.

إذا كان النطاق المطلوب يمتد عبر مخزن مؤقت داخلي واحد، يتم إرجاع شريحة من هذا المخزن المؤقت الذي يشارك نطاق الذاكرة الأصلي لهذا المخزن المؤقت. إذا كان النطاق يمتد عبر مخازن مؤقتة متعددة، فمن المحتمل أن تحدث عمليات النسخ لتعطيك مخزن مؤقت موحد.

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` ترجع هذه الدالة كائنًا جديدًا `BufferList` يحتوي على وحدات البايت داخل النطاق المحدد. كلاً من `start` و`end` اختياريان وسيكونان افتراضيين إلى بداية ونهاية القائمة على التوالي.

لن يتم إجراء أي نسخ. تشترك كافة المخازن المؤقتة في النتيجة الذاكرة مع القائمة الأصلية.

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()` ينسخ محتوى القائمة في المخزن المؤقت `dest`، بدءًا من `destStart` والمحتوية على وحدات البايت ضمن النطاق المحدد بـ`srcStart` إلى `srcEnd`. `destStart` و`start` و`end` اختيارية وستكون افتراضية إلى بداية المخزن المؤقت `dest` وبداية القائمة ونهايتها على التوالي.

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` ينفذ **shallow-copy** من القائمة. تظل المخازن المؤقتة الداخلية كما هي، لذلك إذا قمت بتغيير المخازن المؤقتة الأساسية، فسوف ينعكس التغيير في كل من الأصل والمكرر. هناك حاجة إلى هذه الطريقة إذا كنت ترغب في استدعاء `consume()` أو `pipe()` الاستمرار في الاحتفاظ بالقائمة الأصلية. مثل:

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` سيؤدي إلى تحويل وحدات *البايت من بداية القائمة*. لا يحتاج عدد البايتات المستهلكة إلى الاصطفاف مع أحجام المخازن المؤقتة&mdash; الداخلية سيتم حساب الإزاحة الأولية وفقا لذلك من أجل منحك عرضا متسقا للبيانات.

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` سيرجع تمثيل سلسلة للمخزن المؤقت. يتم تمرير الاختيارية الوسيطات `start` و`end` إلى `slice()`، بينما `encoding` يتم تمريره إلى `toString()` للمخزن المؤقت الناتج. راجع وثائق [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end) لمزيد من المعلومات.

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

يتم تنفيذ جميع طرق قراءة البايت القياسية للواجهة `Buffer` وستعمل عبر حدود المخزن المؤقت الداخلية بشفافية.

راجع الوثائق <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b> لمعرفة كيفية عمل هذه المستندات.

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ])
**BufferListStream** هو Node **[Duplex Stream](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** ، لذلك يمكن قراءته وكتابته مثل دفق العقدة القياسي. يمكنك أيضاً `pipe()` من وإلى مثيل **BufferListStream**.

يأخذ المنشئ رد اتصال اختياري، إذا تم توفيره، يتم استدعاء رد الاتصال باستخدام وسيطة خطأ متبوعة بإشارة إلى مثيل **bl**، عندما `bl.end()` يتم استدعاؤه (أي من دفق متصل بالأنابيب). هذه طريقة ملائمة لجمع محتويات البث بالكامل، خاصة عندما يكون البث *مكتظًا*، مثل دفق الشبكة.

عادة، لا توجد وسيطات مطلوبة للمنشئ، ولكن يمكنك تهيئة القائمة عن طريق المرور في كائن `Buffer` واحد أو صفيف من الكائنات `Buffer`.

`new` ليس مطلوبًا بشكل صارم، إذا لم تقم بإنشاء كائن جديد، سيتم ذلك تلقائيًا نيابة عنك حتى تتمكن من إنشاء مثيل جديد ببساطة مع:

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

N.B. لأسباب تتعلق بالتوافق مع الإصدارات السابقة، يكون `BufferListStream` هو **الافتراضي** عندما تقوم بـ`require('bl')`:

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>المساهمون

يتم إحضار **bl** إليك من قبل المتسللين التاليين:

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>الترخيص &amp; حقوق النشر

حقوق الطبع والنشر (ج) 2013-2019 المساهمين bl (المذكورة أعلاه).

تم إصدار bl بموجب ترخيص MIT. جميع الحقوق غير الممنوحة صراحة في ترخيص معهد ماساتشوستس للتكنولوجيا محفوظة. راجع ملف LICENSE.md المضمن لمزيد من التفاصيل.
