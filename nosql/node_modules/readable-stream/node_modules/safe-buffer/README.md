---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: ar-SA
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052924"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![downloads][downloads-image]][downloads-url] [![javascript style guide][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>واجهة برمجة تطبيقات المخزن المؤقت Node.js أكثر أمانًا

**استخدم واجهات برمجة تطبيقات Node.js Buffer الجديدة (`Buffer.from`، `Buffer.alloc`، `Buffer.allocUnsafe`، `Buffer.allocUnsafeSlow`) في جميع إصدارات Node.js.**

**يستخدم التنفيذ المضمن عند توفره.**

## <a name="install"></a>التثبيت

```
npm install safe-buffer
```

## <a name="usage"></a>الاستخدام

الهدف من هذه الحزمة هو توفير بديل آمن node.js `Buffer`.

إنه بديل سريع لـ`Buffer`. يمكنك استخدامه عن طريق إضافة سطر `require` واحد إلى الجزء العلوي من وحدات node.js الخاصة بك:

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>Class Method: Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

يخصص `Buffer` جديدًا باستخدام `array` من ثمانيات البتات.

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

سيتم طرح `TypeError` إذا `array` لم يكن `Array`.

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} خاصية `.buffer` لـ`TypedArray` أو `new ArrayBuffer()`
* `byteOffset` {Number} افتراضي: `0`
* `length` {Number} افتراضي: `arrayBuffer.length - byteOffset`

عند تمرير مرجع إلى الخاصية `.buffer` بمثيل `TypedArray`، سيشارك `Buffer` الذي تم إنشاؤه حديثًا نفس الذاكرة المخصصة مثل TypedArray.

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

يحدد الخيار وسيطات `byteOffset` و`length` نطاق ذاكرة داخل `arrayBuffer` الذي سيتم مشاركته بواسطة `Buffer`.

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

سيتم طرح `TypeError` إذا `arrayBuffer` لم يكن `ArrayBuffer`.

### <a name="class-method-bufferfrombuffer"></a>Class Method: Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

ينسخ البيانات `buffer` التي تم تمريرها إلى مثيل `Buffer` جديد.

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

سيتم طرح `TypeError` إذا `buffer` لم يكن `Buffer`.

### <a name="class-method-bufferfromstr-encoding"></a>Class Method: Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String} سلسلة للتشفير.
* `encoding` {String} تشفير للاستخدام، افتراضي: `'utf8'`

ينشئ `Buffer` جديدًا يحتوي على سلسلة JavaScript `str` معينة. إذا تم توفيرها، تحدد المعلمة `encoding` ترميز الأحرف.
إذا لم يتم توفيرها، تعيين الإعدادات الافتراضية `encoding` لـ`'utf8'`.

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

سيتم طرح `TypeError` إذا `str` لم يكن سلسلة.

### <a name="class-method-bufferallocsize-fill-encoding"></a>Class Method: Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} افتراضي: `undefined`
* `encoding` {String} افتراضي: `utf8`

يخصص `Buffer` جديد بـ`size` من البايتات. إذا كان `fill` `undefined` سيكون `Buffer` *ممتلئ بالأصفار*.

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

يجب أن يكون `size` أقل من أو يساوي قيمة `require('buffer').kMaxLength` (على معماريات 64 بت، `kMaxLength` هو `(2^31)-1`). خلاف ذلك، يتم إلقاء [`RangeError`][]. سيتم إنشاء مخزن مؤقت بطول صفري إذا تم تحديد `size` أقل من أو يساوي 0.

إذا `fill` تم تحديده، ستتم تهيئة المخصص `Buffer` عن طريق استدعاء `buf.fill(fill)`. لمزيد من المعلومات، راجع [`buf.fill()`][].

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

إذا تم تحديد `fill` و`encoding` كليهما، ستتم تهيئة المخصص `Buffer` عن طريق استدعاء `buf.fill(fill, encoding)`. على سبيل المثال:

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

يمكن أن يكون استدعاء `Buffer.alloc(size)` أبطأ بكثير من البديل `Buffer.allocUnsafe(size)` ولكنه يضمن أن محتويات المثيل `Buffer` الذي تم إنشاؤه حديثًا لن *يحتوي أبدًا على بيانات حساسة*.

سيتم طرح `TypeError` إذا `size` لم يكن رقمًا.

### <a name="class-method-bufferallocunsafesize"></a>Class Method: Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

يخصص `Buffer` *غير مليئ بالأصفار* بـ`size` من البايتات.  يجب أن يكون `size` أقل من أو يساوي قيمة `require('buffer').kMaxLength` (على معماريات 64 بت، `kMaxLength` هو `(2^31)-1`). خلاف ذلك، يتم إلقاء [`RangeError`][]. سيتم إنشاء مخزن مؤقت بطول صفري إذا تم تحديد `size` أقل من أو يساوي 0.

*لا تتم تهيئة* الذاكرة الأساسية للمثيلات `Buffer` التي تم إنشاؤها بهذه الطريقة. محتويات `Buffer` المنشأة حديثًا غير معروفة *وقد تحتوي على بيانات حساسة*. استخدم [][`buf.fill(0)`] لتهيئة هذه المثيلات `Buffer` إلى أصفار.

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

سيتم طرح `TypeError` إذا `size` لم يكن رقمًا.

لاحظ أن الوحدة النمطية `Buffer` تقوم مسبقًا بتخصيص مثيل داخلي `Buffer` بحجم `Buffer.poolSize` يستخدم كتجمع للتخصيص السريع للمثيلات الجديدة `Buffer` التي تم إنشاؤها باستخدام `Buffer.allocUnsafe(size)` (والدالة الإنشائية `new Buffer(size)` المهمل) فقط عندما يكون `size` أقل من أو يساوي `Buffer.poolSize >> 1` (الطابق `Buffer.poolSize` مقسومًا على اثنين). القيمة الافتراضية لـ`Buffer.poolSize` هي `8192` ولكن يمكن تعديلها.

استخدام تجمع الذاكرة الداخلية المخصص مسبقًا هو فارق أساسي بين استدعاء `Buffer.alloc(size, fill)` و`Buffer.allocUnsafe(size).fill(fill)`. بشكل خاص، `Buffer.alloc(size, fill)` لن يستخدم *أبدًا* تجمع ذاكرة التخزين المؤقت الداخلية، بينما `Buffer.allocUnsafe(size).fill(fill)` *سيستخدم* ذاكرة التخزين المؤقت الداخلية إن كان `size` أقل من أو يساوي نصف `Buffer.poolSize`. الفرق دقيق ولكن يمكن أن يكون مهمًا عندما يتطلب التطبيق الأداء الإضافي الذي يوفره `Buffer.allocUnsafe(size)`.

### <a name="class-method-bufferallocunsafeslowsize"></a>Class Method: Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

يخصص `Buffer` جديدة *غير مملوءة بالأصفار* وغير مجمعة بها `size` من البايتات.  يجب أن يكون `size` أقل من أو يساوي قيمة `require('buffer').kMaxLength` (على معماريات 64 بت، `kMaxLength` هو `(2^31)-1`). خلاف ذلك، يتم إلقاء [`RangeError`][]. سيتم إنشاء مخزن مؤقت بطول صفري إذا تم تحديد `size` أقل من أو يساوي 0.

*لا تتم تهيئة* الذاكرة الأساسية للمثيلات `Buffer` التي تم إنشاؤها بهذه الطريقة. محتويات `Buffer` المنشأة حديثًا غير معروفة *وقد تحتوي على بيانات حساسة*. استخدم [][`buf.fill(0)`] لتهيئة هذه المثيلات `Buffer` إلى أصفار.

عند استخدام `Buffer.allocUnsafe()` لتخصيص مثيلات جديدة `Buffer`، يتم تقسيم التخصيصات تحت 4 كيلوبايت، بشكل افتراضي، من مثيلات واحدة مخصصة مسبقًا `Buffer`. هذا يسمح للتطبيقات بتجنب النفقات العامة لجمع القمامة لإنشاء العديد من المخازن المؤقتة المخصصة بشكل فردي. يعمل هذا النهج على تحسين كل من الأداء واستخدام الذاكرة من خلال القضاء على الحاجة إلى تتبع وتنظيف أكبر عدد ممكن من الكائنات `Persistent`.

ومع ذلك، في الحالة التي قد يحتاج فيها المطور إلى الاحتفاظ بجزء صغير من الذاكرة من تجمع لفترة زمنية غير محددة، قد يكون من المناسب إنشاء مثيل مخزن مؤقت غير مجمع باستخدام `Buffer.allocUnsafeSlow()` ثم نسخ البتات ذات الصلة.

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

يجب استخدام `Buffer.allocUnsafeSlow()` فقط كملاذ أخير *بعد* أن يلاحظ المطور احتفاظًا غير مبرر بالذاكرة في تطبيقاته.

سيتم طرح `TypeError` إذا `size` لم يكن رقمًا.

### <a name="all-the-rest"></a>كل ما تبقى

بقية واجهة برمجة التطبيقات `Buffer` هي نفسها تمامًا كما في node.js.
[اطلع على المستندات](https://nodejs.org/api/buffer.html).


## <a name="related-links"></a>الارتباطات ذات الصلة

- موضوع Node.js[: Buffer(number) ](https://github.com/nodejs/node/issues/4660) غير آمن
- طلب تحسين [Node.js: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() soft-deprecate](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>لماذا `Buffer` غير آمن؟

اليوم، يتم تحميل منشئ node.js `Buffer` بشكل زائد للتعامل مع العديد من أنواع الوسيطات المختلفة مثل `String`، `Array`، `Object`، `TypedArrayView` (`Uint8Array`، إلخ) `ArrayBuffer` وأيضًا `Number`.

تم تحسين واجهة برمجة التطبيقات للراحة: يمكنك رمي أي نوع عليها، وستحاول القيام بما تريد.

نظرًا لأن منشئ المخزن المؤقت قوي جداً، فغالباً ما ترى تعليمة برمجية مثل هذه:

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***ولكن ماذا يحدث إذا `toHex` تم استدعاؤه بوسيطة `Number`؟***

### <a name="remote-memory-disclosure"></a>الكشف عن الذاكرة عن بعد

إذا تمكن أحد المهاجمين من جعل البرنامج الخاص بك يتصل `Buffer` بالمنشئ باستخدام وسيطة، فيمكنه جعله يخصص ذاكرة غير مهيأة `Number` من عملية node.js.
قد يؤدي ذلك إلى الكشف عن مفاتيح TLS الخاصة أو بيانات المستخدم أو كلمات مرور قاعدة البيانات.

عندما يتم تمرير وسيطة `Number` لمنشئ `Buffer`، فإنه يرجع **كتلة غير مهيأة** من ذاكرة `size` المحدد. عند إنشاء `Buffer` مثل هذا، **يجب** عليك الكتابة فوق المحتويات قبل إعادتها إلى المستخدم.

من [مستندات node.js](https://nodejs.org/api/buffer.html#buffer_new_buffer_size):

> `new Buffer(size)`
>
> - رقم `size`
>
> لا تتم تهيئة الذاكرة الأساسية للمثيلات `Buffer` التي تم إنشاؤها بهذه الطريقة.
> **محتويات `Buffer` المنشأة حديثًا غير معروفة وقد تحتوي على بيانات حساسة.** استخدم `buf.fill(0)` لتهيئة مخزن مؤقت إلى أصفار.

(التأكيد على منطقتنا.)

عندما ينوي المبرمج إنشاء رمز غير مهيأ `Buffer`، غالبًا ما ترى رمزًا كهذا:

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>هل سيكون هذا مشكلة في التعليمات البرمجية الحقيقية؟

نعم. من الشائع بشكل مدهش أن تنسى التحقق من نوع المتغيرات الخاصة بك بلغة مكتوبة ديناميكيًا مثل جافا سكريبت.

عادة ما تكون عواقب افتراض النوع الخاطئ هي تعطل برنامجك مع استثناء لم يتم اكتشافه. لكن وضع الفشل لنسيان التحقق من نوع الحجج للمنشئ `Buffer` أكثر كارثية.

في ما يلي مثال على خدمة ضعيفة تأخذ حمولة JSON وتحولها إلى سداسي عشري:

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

في هذا المثال، يجب على عميل http فقط الإرسال:

```json
{
  "str": 1000
}
```

وسوف يستعيد 1000 بايت من الذاكرة غير المهيأة من الخادم.

هذا خطأ خطير للغاية. إنه مشابه في شدته [لخطأ Heartbleed](http://heartbleed.com/) الذي سمح بالكشف عن ذاكرة عملية OpenSSL من قبل المهاجمين عن بعد.


### <a name="which-real-world-packages-were-vulnerable"></a>ما هي حزم العالم الحقيقي التي كانت عرضة للخطر؟

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

لقد وجدت أنا ([Feross Aboukhadijeh](http://feross.org/)) و[Mathias Buus](https://github.com/mafintosh) هذه المشكلة في إحدى حزمنا الخاصة، [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). سيسمح الخطأ لأي شخص على الإنترنت بإرسال سلسلة من الرسائل إلى مستخدم `bittorrent-dht` وحمله على الكشف عن 20 بايت في وقت الذاكرة غير المهيأة من عملية node.js.

إليك [الأمر](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8) الذي أصلحه. لقد أصدرنا إصدارًا ثابتًا جديدًا، وأنشأنا [كشفا عن Project أمان العقدة](https://nodesecurity.io/advisories/68)، وأهملنا جميع الإصدارات الضعيفة على npm حتى يحصل المستخدمون على تحذير للترقية إلى إصدار أحدث.

#### [`ws`](https://www.npmjs.com/package/ws)

وهذا يجعلنا نتساءل عما إذا كانت هناك حزم أخرى ضعيفة. بالتأكيد، في غضون فترة زمنية قصيرة، وجدنا نفس المشكلة في [`ws`](https://www.npmjs.com/package/ws)، تطبيق WebSocket الأكثر شعبية في node.js.

إذا تم استدعاء بعض واجهات برمجة التطبيقات باستخدام معلمات `Number` بدلًا من `String` أو `Buffer` كما هو متوقع، يتم الكشف عن ذاكرة الخادم غير المهيأة إلى النظير البعيد.

كانت هذه هي الطرق الضعيفة:

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

إليك خادم مقبس ضعيف مع بعض وظائف الصدى:

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

استدعى `socket.send(number)` الخادم، وسيكشف عن ذاكرة الخادم.

إليك [الإصدار](https://github.com/websockets/ws/releases/tag/1.0.1) الذي تم فيه إصلاح المشكلة، مع شرح أكثر تفصيلًا. الدعائم إلى [Arnout Kazemier](https://github.com/3rd-Eden) للحل السريع. إليك [الكشف عن Node Security Project](https://nodesecurity.io/advisories/67).


### <a name="whats-the-solution"></a>ما هو الحل؟

من المهم أن توفر node.js طريقة سريعة للحصول على الذاكرة وإلا فإن التطبيقات ذات الأداء الحرج ستصبح أبطأ بكثير دون داع.

لكننا بحاجة إلى طريقة أفضل *للإشارة إلى هدفنا* كمبرمجين. **عندما نريد ذاكرة غير مهيأة، يجب أن نطلبها صراحة.**

لا ينبغي تعبئة الوظائف الحساسة في واجهة برمجة تطبيقات صديقة للمطورين تقبل بشكل فضفاض العديد من الأنواع المختلفة. يشجع هذا النوع من واجهة برمجة التطبيقات الممارسة الكسولة لتمرير المتغيرات دون التحقق من النوع بعناية فائقة.

#### <a name="a-new-api-bufferallocunsafenumber"></a>واجهة برمجة تطبيقات جديدة: `Buffer.allocUnsafe(number)`

يجب أن تكون وظيفة إنشاء مخازن مؤقتة بذاكرة غير مهيأة جزءًا من واجهة برمجة تطبيقات أخرى. نقترح `Buffer.allocUnsafe(number)`. بهذه الطريقة، فهي ليست جزءًا من واجهة برمجة التطبيقات التي تحصل بشكل متكرر على مدخلات المستخدم من جميع أنواع الأنواع المختلفة التي يتم تمريرها إليها.

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>كيف يمكننا إصلاح أساس node.js؟

أرسلنا [PR إلى أساس node.js](https://github.com/nodejs/node/pull/4514) (مدمجة كـ`semver-major`) والتي تدافع ضد حالة واحدة:

```js
var str = 16
new Buffer(str, 'utf8')
```

في هذه الحالة، من المفترض أن يقصد المبرمج أن تكون الوسيطة الأولى عبارة عن سلسلة، نظرًا لأنهم مرروا ترميزًا كوسيطة ثانية. اليوم، ستقوم node.js بتخصيص ذاكرة غير مهيأة في حالة `new Buffer(number, encoding)`، وهو على الأرجح ليس ما قصده المبرمج.

ولكن هذا ليس سوى حل جزئي، لأنه إذا فعل المبرمج `new Buffer(variable)` (بدون معلمة `encoding`)، فلا توجد طريقة لمعرفة ما يقصده. إذا كان `variable` في بعض الأحيان رقما، يتم إرجاع الذاكرة غير المهيأة في بعض الأحيان.

### <a name="whats-the-real-long-term-fix"></a>ما هو الحل الحقيقي على المدى الطويل؟

يمكننا إهمال وإزالة `new Buffer(number)` واستخدام `Buffer.allocUnsafe(number)` عندما نحتاج إلى ذاكرة غير مهيأة. لكن هذا من شأنه أن يكسر آلاف من الحزم.

~~نعتقد أن أفضل حل هو:~~

~~1. تغيير `new Buffer(number)`لإرجاع ذاكرة آمنة وصفرية~~

~~2. إنشاء واجهة برمجة التطبيقات جديدة لإنشاء مخازن مؤقتة غير مهيئة. نقترح: `Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>Update

نحن ندعم الآن إضافة ثلاث واجهات برمجة تطبيقات جديدة:

- `Buffer.from(value)` - تحويل من أي نوع إلى المخزن المؤقت
- `Buffer.alloc(size)` - إنشاء مخزن مؤقت مملوء صفر
- `Buffer.allocUnsafe(size)` - إنشاء مخزن مؤقت غير مهيأ مع حجم معين

هذا يحل المشكلة الأساسية التي أثرت على `ws`و`bittorrent-dht` والتي يتم خداع `Buffer(variable)` بها لاتخاذ وسيطة رقمية.

بهذه الطريقة، تستمر الشفرة الحالية في العمل وسيكون التأثير على النظام البيئي npm ضئيلًا. بمرور الوقت، يمكن لمشرفي npm ترحيل التعليمات البرمجية ذات الأداء الحرج لاستخدام `Buffer.allocUnsafe(number)` بدلًا من `new Buffer(number)`.


### <a name="conclusion"></a>الختام

نعتقد أن هناك مشكلة تصميم خطيرة في واجهة برمجة التطبيقات `Buffer` كما هي موجودة اليوم. إنه يعزز البرامج غير الآمنة من خلال وضع وظائف عالية المخاطر في واجهة برمجة تطبيقات مريحة مع "بيئة عمل المطورين" الودية.

لم يكن هذا مجرد تمرين نظري لأننا وجدنا المشكلة في بعض حزم npm الأكثر شعبية.

لحسن الحظ، هناك حل سهل يمكن تطبيقه اليوم. استخدم `safe-buffer` بدلًا من `buffer`.

```js
var Buffer = require('safe-buffer').Buffer
```

في نهاية المطاف، نأمل أن يتمكن node.js الأساسية من التحول إلى هذا السلوك الجديد الأكثر أمانًا. نعتقد أن التأثير على النظام البيئي سيكون ضئيلًا لأنه ليس تغييرًا مفاجئًا.
سيتم تحديث الحزم الشائعة التي يتم صيانتها جيدا لاستخدام `Buffer.alloc` بسرعة، في حين أن الحزم القديمة غير الآمنة ستصبح آمنة بطريقة سحرية من ناقل الهجوم هذا.


## <a name="links"></a>الروابط

- [Node.js PR: المخزن المؤقت: إلقاء إذا تم تمرير كل من الطول وenc](https://github.com/nodejs/node/pull/4514)
- [الكشف عن Node Security Project لـ`ws`](https://nodesecurity.io/advisories/67)
- [الكشف عن Node Security Project لـ`bittorrent-dht`](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>الائتمان

تم اكتشاف المشكلات الأصلية في `bittorrent-dht` ([الإفصاح](https://nodesecurity.io/advisories/68)) و `ws` ([الإفصاح](https://nodesecurity.io/advisories/67)) من قبل [Mathias Buus](https://github.com/mafintosh)و[Feross Aboukhadijeh](http://feross.org/).

شكرًا لـ[Adam Baldwin](https://github.com/evilpacket) للمساعدة في الكشف عن هذه المشكلات وعلى عمله في إدارة [Project Node Security](https://nodesecurity.io/).

شكرًا لـ[John Hiesey](https://github.com/jhiesey) على التدقيق اللغوي لهذا الملف التمهيدي وتدقيق الرمز.


## <a name="license"></a>الترخيص

MIT. حقوق الطبع والنشر (C) [Feross Aboukhadijeh](http://feross.org)
